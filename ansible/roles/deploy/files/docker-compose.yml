x-user: &user
  user: ${PUID:-1000}:${PGID:-1000}

x-networks-proxy: &networks-proxy
  networks:
    proxy: {}

x-environment: &environment
  environment:
    - TZ=$TZ
    - PUID=$PUID
    - PGID=$PGID

x-proxy-labels: &proxy-labels
  traefik.enable: true
  traefik.docker.network: "proxy"

x-security: &security
  security_opt:
    - no-new-privileges:true

x-common: &common
  security_opt:
    - no-new-privileges:true
  user: ${PUID:-1000}:${PGID:-1000}
  restart: unless-stopped
  pull_policy: always

services:
  cloudflare-ddns:
    image: favonia/cloudflare-ddns:latest
    container_name: cloudflare-ddns
    network_mode: host
    <<: [*common]
    read_only: true
    # Make the container filesystem read-only (optional but recommended)
    cap_drop: [all]
    # Drop all Linux capabilities (optional but recommended)
    environment:
      - CLOUDFLARE_API_TOKEN=$CF_DNS_API_TOKEN
        # Your Cloudflare API token
      - DOMAINS=ddns.${PUBLIC_DOMAIN}
      # Tell Cloudflare to cache webpages and hide your IP (optional)
      - PROXIED=false
      - IP6_PROVIDER=none
  traefik:
    image: traefik:v3.6.1
    container_name: traefik
    restart: unless-stopped
    pull_policy: always
    security_opt:
      - no-new-privileges:true
    # Needed by any container that accesses docker.sock
    group_add:
      - ${PGID:-1000}
    networks:
      proxy: {}
        # # Required for Authentik
        # aliases:
        #   - auth.${PUBLIC_DOMAIN}
    ports:
      - 80:80
      - 443:443
    environment:
      - TZ
      # https://go-acme.github.io/lego/dns/cloudflare/
      # Zone / Zone / Read on the specific zone for which I use Traefik
      - CF_ZONE_API_TOKEN
      # Zone / DNS / Edit on the specific zone for which I use Traefik
      - CF_DNS_API_TOKEN
      - PUBLIC_DOMAIN
      # Used by traefik-oidc-auth middleware
      - TRAEFIK_OIDC_AUTH_SECRET
      - TRAEFIK_OIDC_CLIENT_ID
      - TRAEFIK_OIDC_CLIENT_SECRET
    volumes:
      - /etc/localtime:/etc/localtime:ro
      - /var/run/docker.sock:/var/run/docker.sock:ro
      - ./config/traefik/config:/etc/traefik/config:ro
      - ./config/traefik/traefik.yml:/traefik.yml:ro
      - ./config/traefik/acme.json:/acme.json:rw
      - ./config/traefik/usersfile.txt:/usersfile.txt
    labels:
      traefik.enable: true
      # Middlewares
      traefik.http.middlewares.traefik-auth.basicauth.usersfile: "/usersfile.txt"
      traefik.http.middlewares.traefik-https-redirect.redirectscheme.scheme: "https"
      traefik.http.middlewares.sslheader.headers.customrequestheaders.X-Forwarded-Proto: "https"
      # HTTP entrypoint
      traefik.http.routers.traefik.entrypoints: "http"
      traefik.http.routers.traefik.rule: "Host(`traefik.${PUBLIC_DOMAIN}`)"
      traefik.http.routers.traefik.middlewares: "traefik-https-redirect,public@file"
      # HTTPS entrypoint
      traefik.http.routers.traefik-secure.entrypoints: "https"
      traefik.http.routers.traefik-secure.rule: "Host(`traefik.${PUBLIC_DOMAIN}`)"
      traefik.http.routers.traefik-secure.middlewares: "traefik-auth,public@file"
      traefik.http.routers.traefik-secure.tls: "true"
      traefik.http.routers.traefik-secure.tls.certresolver: "cloudflare"
      traefik.http.routers.traefik-secure.tls.domains[0].main: "${PUBLIC_DOMAIN}"
      traefik.http.routers.traefik-secure.tls.domains[0].sans: "*.${PUBLIC_DOMAIN}"
      traefik.http.routers.traefik-secure.service: "api@internal"
  # Storage backend for gatus
  gatus_postgres:
    image: postgres
    container_name: gatus_postgres
    volumes:
      - ./config/gatus_postgres:/var/lib/postgresql
    networks:
      gatus: {}
    <<: [*common]
    environment:
      - POSTGRES_DB=${GATUS_POSTGRES_DB}
      - POSTGRES_USER=${GATUS_POSTGRES_USER}
      - POSTGRES_PASSWORD=${GATUS_POSTGRES_PASSWORD}
  gatus:
    image: twinproduction/gatus:v5.32.0
    container_name: gatus
    restart: unless-stopped
    depends_on:
      - gatus_postgres
    <<: [*common]
    networks:
      proxy: {}
      gatus: {}
    environment:
      - POSTGRES_DB=${GATUS_POSTGRES_DB}
      - POSTGRES_USER=${GATUS_POSTGRES_USER}
      - POSTGRES_PASSWORD=${GATUS_POSTGRES_PASSWORD}
      - PUBLIC_DOMAIN
    volumes:
      - ./config/gatus:/config
    labels:
      <<: *proxy-labels
      traefik.http.routers.status.entrypoints: "http"
      traefik.http.routers.status.rule: "Host(`status.${PUBLIC_DOMAIN}`)"
      traefik.http.middlewares.status-https-redirect.redirectscheme.scheme: "https"
      traefik.http.routers.status.middlewares: "status-https-redirect"
      traefik.http.routers.status-secure.entrypoints: "https"
      traefik.http.routers.status-secure.rule: "Host(`status.${PUBLIC_DOMAIN}`)"
      traefik.http.routers.status-secure.tls: "true"
      traefik.http.routers.status-secure.service: "status"
      traefik.http.services.status.loadbalancer.server.port: "8080"
      traefik.http.routers.status-secure.middlewares: "public@file"
    pull_policy: always
  # Storage backend for gatus
  pocketid_postgres:
    image: postgres
    container_name: pocketid_postgres
    volumes:
      - ./config/pocketid_postgres:/var/lib/postgresql
    networks:
      pocketid: {}
    <<: [*common]
    environment:
      - POSTGRES_DB=${POCKETID_POSTGRES_DB}
      - POSTGRES_USER=${POCKETID_POSTGRES_USER}
      - POSTGRES_PASSWORD=${POCKETID_POSTGRES_PASSWORD}
  pocketid:
    image: ghcr.io/pocket-id/pocket-id:v1
    container_name: pocketid
    restart: unless-stopped
    depends_on:
      - pocketid_postgres
    <<: [*common]
    networks:
      proxy: {}
      pocketid: {}
    volumes:
      - "./config/pocketid:/app/data"
    environment:
      - APP_NAME="${PUBLIC_DOMAIN} access portal"
      - APP_URL=https://auth.${PUBLIC_DOMAIN}
      - TRUST_PROXY=true
      - MAXMIND_LICENSE_KEY
      - DB_PROVIDER=postgres
      - DB_CONNECTION_STRING=postgres://${POCKETID_POSTGRES_USER}:${POCKETID_POSTGRES_PASSWORD}@pocketid_postgres:5432/${POCKETID_POSTGRES_DB}
      - KEYS_STORAGE=database
      - ENCRYPTION_KEY=${POCKETID_ENCRYPTION_KEY}
      # Alerting via SMTP
      - SMTP_HOST
      - SMTP_PORT=587
      - SMTP_FROM=${SMTP_USER}
      - SMTP_TO
      - SMTP_USER
      - SMTP_PASSWORD
      - SMTP_TLS=starttls
      - EMAIL_ONE_TIME_ACCESS_AS_ADMIN_ENABLED=true
      # Wireguard peer IP for healthcheck
      - WIREGUARD_PEER1
    # Optional healthcheck
    healthcheck:
      test: ["CMD", "/app/pocket-id", "healthcheck"]
      interval: 1m30s
      timeout: 5s
      retries: 2
      start_period: 10s
    labels:
      <<: *proxy-labels
      traefik.http.routers.pocket-id.entrypoints: "http"
      traefik.http.routers.pocket-id.rule: "Host(`auth.${PUBLIC_DOMAIN}`)"
      traefik.http.middlewares.pocket-id-https-redirect.redirectscheme.scheme: "https"
      traefik.http.routers.pocket-id.middlewares: "pocket-id-https-redirect"
      traefik.http.routers.pocket-id-secure.entrypoints: "https"
      traefik.http.routers.pocket-id-secure.rule: "Host(`auth.${PUBLIC_DOMAIN}`)"
      traefik.http.routers.pocket-id-secure.tls: "true"
      traefik.http.routers.pocket-id-secure.service: "pocket-id"
      traefik.http.services.pocket-id.loadbalancer.server.port: "1411"
      traefik.http.routers.pocket-id-secure.middlewares: "public@file"
  # watchtower manages auto updates. this is optional.
  watchtower:
    image: nickfedor/watchtower
    container_name: watchtower
    restart: unless-stopped
    group_add:
      - ${PGID:-1000}
    environment:
      # Requires label: - "com.centurylinklabs.watchtower.enable=true"
      - WATCHTOWER_LABEL_ENABLE
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock
    # check for updates once an hour (interval is in seconds)
    command: --interval 3600 --cleanup

networks:
  proxy:
    external: true
  gatus:
    internal: true
  pocketid:
    internal: true
