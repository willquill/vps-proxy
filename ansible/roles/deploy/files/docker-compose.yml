x-user: &user
  user: ${PUID:-1000}:${PGID:-1000}

x-networks-proxy: &networks-proxy
  networks:
    proxy: {}

x-environment: &environment
  environment:
    - TZ=$TZ
    - PUID=$PUID
    - PGID=$PGID

x-proxy-labels: &proxy-labels
  traefik.enable: true
  traefik.docker.network: "proxy"

x-security: &security
  security_opt:
    - no-new-privileges:true

x-common: &common
  security_opt:
    - no-new-privileges:true
  user: ${PUID:-1000}:${PGID:-1000}
  restart: unless-stopped
  pull_policy: always

services:
  cloudflare-ddns:
    image: favonia/cloudflare-ddns:latest
    container_name: cloudflare-ddns
    network_mode: host
    <<: [*common]
    read_only: true
    # Make the container filesystem read-only (optional but recommended)
    cap_drop: [all]
    # Drop all Linux capabilities (optional but recommended)
    environment:
      - CLOUDFLARE_API_TOKEN=$CF_DNS_API_TOKEN
      - DOMAINS=ddns2.${PUBLIC_DOMAIN}
      # Tell Cloudflare to cache webpages and hide your IP (optional)
      - PROXIED=false
      - IP6_PROVIDER=none
  crowdsec:
    image: crowdsecurity/crowdsec:v1.7.4
    container_name: crowdsec
    restart: unless-stopped
    depends_on:
      - traefik
    networks:
      proxy: {}
    # Since Traefik and Crowdsec apps run on the same network
    # they can communicate directly and we don't need to expose any ports
    # ports:
    #   - 127.0.0.1:9876:8080 # port mapping for local firewall bouncers
    # expose:
    #   - 8080 # http api for bouncers
    #   - 6060 # metrics endpoint for prometheus
    #   - 7422 # appsec waf endpoint
    volumes:
      # crowdsec container data
      - ./config/crowdsec/data:/var/lib/crowdsec/data
      - ./config/crowdsec/etc:/etc/crowdsec
      # log bind mounts into crowdsec
      - /var/log/auth.log:/var/log/auth.log:ro
      - /var/log/syslog:/var/log/syslog:ro
      # Traefik logs
      - ./logs:/logs
    environment:
      - GID=1000
      - COLLECTIONS=crowdsecurity/traefik crowdsecurity/http-cve crowdsecurity/base-http-scenarios crowdsecurity/sshd crowdsecurity/linux crowdsecurity/appsec-generic-rules crowdsecurity/appsec-virtual-patching crowdsecurity/appsec-crs
      #- CUSTOM_HOSTNAME=my-crowdsec-host123
  # This service rotates the Traefik logs
  logrotate:
    image: samuelrunggaldier/logrotate:latest
    volumes:
      - ./logs:/logs
    environment:
      - $TZ
      - LOGS_PATH=/logs/*.log
      - TRIGGER_INTERVAL=daily
      - MAX_SIZE=100M
      - MAX_BACKUPS=30
      - DELAYCOMPRESS=true
  traefik:
    image: traefik:v3.6.1
    container_name: traefik
    restart: unless-stopped
    pull_policy: always
    security_opt:
      - no-new-privileges:true
    networks:
      proxy: {}
        # # Required for Authentik
        # aliases:
        #   - auth.${PUBLIC_DOMAIN}
    ports:
      - 80:80
      - 443:443
    environment:
      - TZ
      # https://go-acme.github.io/lego/dns/cloudflare/
      # Zone / Zone / Read on the specific zone for which I use Traefik
      - CF_ZONE_API_TOKEN
      # Zone / DNS / Edit on the specific zone for which I use Traefik
      - CF_DNS_API_TOKEN
      - ACME_EMAIL
      # Used by traefik-oidc-auth middleware
      - TRAEFIK_OIDC_AUTH_SECRET
      - TRAEFIK_OIDC_CLIENT_ID
      - TRAEFIK_OIDC_CLIENT_SECRET
      # Not GitHub Secret
      - TRAEFIK_OIDC_PROVIDER_URL
      # To forward requests to LAN
      - PUBLIC_DOMAIN
      - IDM_DOMAIN
      - LAN_SERVICE1
      - LAN_SERVICE2
    volumes:
      - /etc/localtime:/etc/localtime:ro
      - /var/run/docker.sock:/var/run/docker.sock:ro
      - ./logs:/logs
      - ./config/traefik/config:/etc/traefik/config:ro
      - ./config/traefik/traefik.yml:/traefik.yml:ro
      - ./config/traefik/acme.json:/acme.json:rw
      - ./config/traefik/usersfile.txt:/usersfile.txt:ro
      - ./config/traefik/crowdsec-api-key.txt:/crowdsec-api-key.txt:ro
    labels:
      traefik.enable: true
      # HTTPS dashboard
      traefik.http.routers.traefik-dashboard.entrypoints: "websecure"
      traefik.http.routers.traefik-dashboard.rule: "Host(`tvps.${PUBLIC_DOMAIN}`)"
      traefik.http.routers.traefik-dashboard.middlewares: "public-oidc-auth@file"
      traefik.http.routers.traefik-dashboard.tls: "true"
      traefik.http.routers.traefik-dashboard.service: "dashboard@internal"
      # HTTPS API
      traefik.http.routers.traefik-api.entrypoints: "websecure"
      traefik.http.routers.traefik-api.rule: "Host(`tvps.${PUBLIC_DOMAIN}`) && (PathPrefix(`/api`) || PathPrefix(`/oidc/callback`))"
      traefik.http.routers.traefik-api.middlewares: "public-oidc-auth@file"
      traefik.http.routers.traefik-api.tls: "true"
      traefik.http.routers.traefik-api.tls.certresolver: "cloudflare"
      traefik.http.routers.traefik-api.tls.domains[0].main: "${PUBLIC_DOMAIN}"
      traefik.http.routers.traefik-api.tls.domains[0].sans: "*.${PUBLIC_DOMAIN}"
      traefik.http.routers.traefik-api.tls.domains[1].main: "${IDM_DOMAIN}"
      traefik.http.routers.traefik-api.tls.domains[1].sans: "idm.${IDM_DOMAIN}"
      traefik.http.routers.traefik-api.service: "api@internal"
  # Storage backend for gatus
  gatus_postgres:
    image: postgres
    container_name: gatus_postgres
    volumes:
      - ./config/gatus_postgres:/var/lib/postgresql
    networks:
      gatus: {}
    <<: [*common]
    environment:
      - POSTGRES_DB=${GATUS_POSTGRES_DB}
      - POSTGRES_USER=${GATUS_POSTGRES_USER}
      - POSTGRES_PASSWORD=${GATUS_POSTGRES_PASSWORD}
  gatus:
    image: twinproduction/gatus:v5.32.0
    container_name: gatus
    restart: unless-stopped
    depends_on:
      - gatus_postgres
    <<: [*common]
    networks:
      proxy: {}
      gatus: {}
    environment:
      - POSTGRES_DB=${GATUS_POSTGRES_DB}
      - POSTGRES_USER=${GATUS_POSTGRES_USER}
      - POSTGRES_PASSWORD=${GATUS_POSTGRES_PASSWORD}
      - PUBLIC_DOMAIN
      # Alerting via SMTP
      - SMTP_HOST
      - SMTP_FROM=${SMTP_USER}
      - SMTP_TO
      - SMTP_USER
      - SMTP_PASSWORD
      # Monitor LAN
      - IDM_DOMAIN
      - LAN_SERVICE1
      - LAN_SERVICE2
    volumes:
      - ./config/gatus:/config
    labels:
      <<: *proxy-labels
      traefik.http.routers.status.entrypoints: "websecure"
      traefik.http.routers.status.rule: "Host(`status.${PUBLIC_DOMAIN}`)"
      traefik.http.routers.status.tls: "true"
      traefik.http.routers.status.service: "status"
      traefik.http.services.status.loadbalancer.server.port: "8080"
      traefik.http.routers.status.middlewares: "public@file"
    pull_policy: always
  # Storage backend for gatus
  pocketid_postgres:
    image: postgres
    container_name: pocketid_postgres
    volumes:
      - ./config/pocketid_postgres:/var/lib/postgresql
    networks:
      pocketid: {}
    <<: [*common]
    environment:
      - POSTGRES_DB=${POCKETID_POSTGRES_DB}
      - POSTGRES_USER=${POCKETID_POSTGRES_USER}
      - POSTGRES_PASSWORD=${POCKETID_POSTGRES_PASSWORD}
  pocketid:
    image: ghcr.io/pocket-id/pocket-id:v1
    container_name: pocketid
    restart: unless-stopped
    depends_on:
      - pocketid_postgres
    <<: [*common]
    networks:
      proxy: {}
      pocketid: {}
    volumes:
      - "./config/pocketid:/app/data"
    environment:
      - APP_NAME="${PUBLIC_DOMAIN} access portal"
      - APP_URL=https://id.${PUBLIC_DOMAIN}
      - TRUST_PROXY=true
      - MAXMIND_LICENSE_KEY
      - DB_PROVIDER=postgres
      - DB_CONNECTION_STRING=postgres://${POCKETID_POSTGRES_USER}:${POCKETID_POSTGRES_PASSWORD}@pocketid_postgres:5432/${POCKETID_POSTGRES_DB}
      - KEYS_STORAGE=database
      - ENCRYPTION_KEY=${POCKETID_ENCRYPTION_KEY}
      # Alerting via SMTP
      - SMTP_HOST
      - SMTP_PORT=587
      - SMTP_FROM=${SMTP_USER}
      - SMTP_TO
      - SMTP_USER
      - SMTP_PASSWORD
      - SMTP_TLS=starttls
      - EMAIL_ONE_TIME_ACCESS_AS_ADMIN_ENABLED=true
    # Optional healthcheck
    healthcheck:
      test: ["CMD", "/app/pocket-id", "healthcheck"]
      interval: 1m30s
      timeout: 5s
      retries: 2
      start_period: 10s
    labels:
      <<: *proxy-labels
      traefik.http.routers.pocket-id.entrypoints: "websecure"
      traefik.http.routers.pocket-id.rule: "Host(`id.${PUBLIC_DOMAIN}`)"
      traefik.http.routers.pocket-id.tls: "true"
      traefik.http.routers.pocket-id.service: "pocket-id"
      traefik.http.services.pocket-id.loadbalancer.server.port: "1411"
      traefik.http.routers.pocket-id.middlewares: "public@file"
  tuwunel:
    image: ghcr.io/matrix-construct/tuwunel:latest
    container_name: tuwunel
    restart: unless-stopped
    pull_policy: always
    security_opt:
      - no-new-privileges:true
    networks:
      proxy: {}
    volumes:
      - ./config/tuwunel/data:/var/lib/tuwunel
      - ./config/tuwunel/tuwunel.toml:/etc/tuwunel.toml:ro
    environment:
      - TUWUNEL_SERVER_NAME=matrix.${PUBLIC_DOMAIN}
      - TUWUNEL_DATABASE_PATH=/var/lib/tuwunel
      - TUWUNEL_PORT=6167
      - TUWUNEL_ADDRESS=0.0.0.0
      - TUWUNEL_MAX_REQUEST_SIZE=20000000
      - TUWUNEL_ALLOW_REGISTRATION=${TUWUNEL_ALLOW_REGISTRATION:-false}
      - TUWUNEL_REGISTRATION_TOKEN=${TUWUNEL_REGISTRATION_TOKEN:-}
      - TUWUNEL_ALLOW_FEDERATION=true
      - TUWUNEL_TRUSTED_SERVERS=["matrix.org"]
      - TUWUNEL_CONFIG=/etc/tuwunel.toml
      - TUWUNEL_LOG=info
      - TUWUNEL_WELL_KNOWN={client=https://matrix.${PUBLIC_DOMAIN},server=matrix.${PUBLIC_DOMAIN}:443}
    ulimits:
      nofile:
        soft: 1048567
        hard: 1048567
    labels:
      <<: *proxy-labels
      traefik.http.routers.tuwunel.entrypoints: "websecure"
      traefik.http.routers.tuwunel.rule: "Host(`matrix.${PUBLIC_DOMAIN}`)"
      traefik.http.routers.tuwunel.tls: "true"
      traefik.http.routers.tuwunel.service: "tuwunel"
      traefik.http.services.tuwunel.loadbalancer.server.port: "6167"
      traefik.http.routers.tuwunel.middlewares: "public@file"
  # watchtower manages auto updates. this is optional.
  watchtower:
    image: nickfedor/watchtower
    container_name: watchtower
    restart: unless-stopped
    group_add:
      - ${PGID:-1000}
    environment:
      # Requires label: - "com.centurylinklabs.watchtower.enable=true"
      - WATCHTOWER_LABEL_ENABLE
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock
    # check for updates once an hour (interval is in seconds)
    command: --interval 3600 --cleanup

networks:
  proxy:
    external: true
  gatus:
    internal: true
  pocketid:
    internal: true
